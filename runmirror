#!/bin/bash

#
# MIT License
#
# Copyright (c) 2021 Reiikz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

#README   README   README   README   README   README
#THIS SCRIPT DEPENDS ON THE FOLLOWING DEBIAN PACKAGES: psmisc, debmirror, wget
#
# 1- Recomendations on how to set it up
#		1-	modify the configuration setup below according to your mirroring needs,
#			configuration start is marked like this: #--------------------------- START OF CINFIG
#
#		2-	then drop the file onto /usr/local/bin and make sure it has run permissions
#			a nice tip is to give your group permission to edit it, and set the ownership as root:yourgroup
#
#		3-	set it to run periodically with crontab like this: /usr/local/bin/runmirror run
#
#		4-	now let's add a system daemon so it starts up in case there's a power outage or the server gets rebooted
#			drop a unit file on /etc/systemd/system
#			
#			unit file example asuming the user that owns the mirror files is JohnSmith:
#
#				[Unit]
#				Description=My Awesome Mirror Script
#				[Install]
#				WantedBy=multi-user.target
#
#				[Service]
#				Type=simple
#				ExecStart=/usr/local/bin/runmirror srun
#				User=JohnSmith
#				Group=JohnSmith
#
#			note I used srun instead of run, srun checks if the mirror is allowed to run according to the
#			permitted hours you set up in the configuration below, alternatively you can just use run to 
#			ignore the time check completely and run it every time the server is rebooted
#			
#			in case you don't know how, to load the service is: sudo systemctl daemon-reload
#			and to enable it's: sudo systemctl enable the-name-of-the-unitfile-here
#
# 2- Info about the location of the files generated by the script:
#		assuming you did not touch the variables that are outside the:
#			#--------------------------- START OF CINFIG
#			and
#			#------------------------------- END OF CONFIG
#		markers, the logfiles will be stored in the following location:
#		$HOME/.rzms/log <- inside this directory there will be one directory per mirror configuration, each one
#		will be named after the MirrorName, if you have two scripts with the variable MirrorName set as mirror1 and mirror2
#		respectively, there will be two directories: $HOME/.rzms/log/mirror1 and $HOME/.rzms/log/mirror2, these
#		will contain 2 types of special files; latest.log, which contains all the log information from the script for a the currnet
#		day and dumpfile-date.log this will contain all the stdout and stderr from debmirror for a fiven day
#		
#		inside $HOME/.rzms is where each keyring lives separately for each mirror, the directory name format for each keyring is:
#		MirrorName.keyring
#
# 3- Tips
#		1-	you can change the name of this file to whatever you like do keep in mind all of this help
#			assumes that the script's file is called runmirror, although I advice against giving it an extension like for
#			example .sh
#
#		2-	you can use "runmirror getkeyring" to directly run the keyring pulling function
#		
#		3-	you can use "runmirror userfiles" to see the full path to the logfiles and keyrings
#
#		4-	you can use "runmirror hook-log" to see the log in realtime (runs tail -f on the logfile)
#
#		5-	you can use "runmirror hook-dump" to see the dumpfile for debmirror's stdout and stderr (runs tail -f on the file)
#

#--------------------------- START OF CINFIG

# config goes here, you can copy one of the example files

#------------------------------- END OF CONFIG
#IF YOU TOUCH FURTHER FROM THIS POINT BEWARE THAT YOU ARE MODIFYING THE SCRIPT NOT THE CONFIGURATION
###################################
#this environment data is used by the script to retake dead updates
VERSION="0.0.1"
MY_NAME="Reiikz_Mirror_Script"
MY_NAME_LOWER="rzms"

MY_LOCATION="$(realpath $0)"
MY_FILE_NAME="$(basename $0)"

USER_HOME="$(getent passwd $(whoami) | cut -d':' -f6)"
USER_FILES_LOCATION="$USER_HOME/.$MY_NAME_LOWER"
LOG_LOCATION="$USER_FILES_LOCATION/log"
MY_LOG="$LOG_LOCATION/$MirrorName"
# Don't touch the user's keyring, have our own instead
export GNUPGHOME=$USER_FILES_LOCATION/$MirrorName.keyring
if [ ! -e "$GNUPGHOME" ]; then
	mkdir -p $USER_FILES_LOCATION/$MirrorName.keyring
	chmod -R 700 $USER_FILES_LOCATION/$MirrorName.keyring
fi

#FORMATTING CODES
FC_RESET="\e[0m"
FC_BOLD="\e[1m"

#FORMATTING
FC_DEFAULT_COLOR="\e[39m"
FC_RED="\e[31m"
FC_GREEN="\e[32m"
FC_YELLOW="\e[33m"
FC_BLUE="\e[34m"
FC_MAGENTA="\e[35m"
FC_CYAN="\e[36m"
FC_LIGHT_GRAY="\e[37m"
FC_DARK_GRAY="\e[90m"
FC_LIGHT_RED="\e[91m"
FC_LIGHT_GREEN="\e[92m"
FC_LIGHT_YELLOW="\e[93m"
FC_LIGHT_BLUE="\e[94m"
FC_LIGHT_MAGENTA="\e[95m"
FC_LIGHT_CYAN="\e[96m"
FC_WHITE="\e[97m"

#fix wierd behavour after modifying text formatting
PREVIOUS_PS1="$PS1"

MISSING_KEY=no
UPDATED_KEYRING=no
ARCHIVE_UPDATE_FINISHED=no


function isPIDMyself {
	if [ -z "$(lsof -n | grep $1 | grep "$MY_FILE_NAME" | grep -o "$MY_LOCATION")" ]; then
		return 1
	else
		return 0
	fi
}

function riseCrudeLock {
	if readbool "$__SERVER"; then
		file="${CURRENT_SERVER[path]}/.meta/.$1.lockfile"
	else
		file="$USER_FILES_LOCATION/.$1.lockfile"
	fi
	if [ -e "$file" ]; then
		source "$file"
		if [ "$LOCKED_PID" == "$$" ]; then
			rm "$file"
			log "risen lock '$1'"
			return 0
		else
			logs "$FC_BOLD$FC_RED" "tried to rise lock '$1' from another process: $LOCKED_PID"
			return 1
		fi
	else
		log "tried to rise lock '$1' which was not present"
		return 2
	fi
}

# crudeLock "lockname" <timeout to get it>
function crudeLock {
	[ -z "$2" ] && timeout=60
	if readbool "$__SERVER"; then
		file="${CURRENT_SERVER[path]}/.meta/.$1.lockfile"
		fl="$(dirname "$file")"
		if [ ! -d "$fl" ]; then
			if [ -e "$fl" ]; then
				rm -rf "$fl"
			fi
			mkdir -p "$fl"
		fi
	else
		file="$USER_FILES_LOCATION/.$1.lockfile"
	fi
	start=$(timestamp)
	while [ $(( $(timestamp) - $start )) -lt $timeout ]; do
		if [ ! -e "$file" ]; then
			echo "LOCKED_PID=\"$$\"" > "$file"
			echo "LOCKED_FROM=\"$MY_LOCATION\"" >> "$file"
			log "acquiered lock '$1'"
			return 0
		else
			source "$file"
			if ! isPIDMyself $LOCKED_PID; then
				if rm "$file"; then
					log "risen lock $1, of dead $MY_NAME instance"
				else
					log "could not rise lock $1"
				fi
			fi
		fi
		sleep 1
	done
	if [ $(( $(timestamp) - $start )) -ge $timeout ]; then
		logs "$FC_BOLD$FC_RED" "timed out after $timeout""s while trying to acquire lock $1"
		return 1
	fi
}

function logTimeFormat {
	echo -n "[$(date "+%H:%M:%S")]:"
}

function toLower {
	echo "$1" | tr '[:upper:]' '[:lower:]'
}

function readbool {
	if [ -z "$1" ]; then
		return 2
	fi
	if [ "$1" != "0" ] && [ "$(toLower $1)" != "false" ] && [ "$(toLower $1)" != "no" ]; then
		return 0
	else
		return 1
	fi
}

function displayCopyright {
	echo "$MY_NAME v$VERSION"
	echo "Copyright (c) 2021 Reiikz"
	echo "MIT LICENCE"
}

function timestamp {
	echo -n "$(date "+%s")"
}

function day {
	echo -n "$(date "+%d")"
}

function today {
	echo -n "$(date "+%d-%m-%Y")"
}

function unixTimeDiffToReadable {
    minutes=$(($1/60))
    hours=$(($minutes/60))
    [ $hours -gt 0 ] && minutes=$(($minutes - $(($hours * 60))))
    days=$(($hours/24))
    [ $days -gt 0 ] && hours=$(($hours - $(($days * 24))))
    weeks=$(($days/7))
    [ $weeks -gt 0 ] && days=$(($days - $(($weeks * 7))))
    seconds=$(($1%60))

    if [ $seconds -gt 0 ]; then
        seconds="$seconds""s"
    else
        unset seconds
    fi

    if [ $minutes -gt 0 ]; then
        minutes="$minutes""m "
    else
        unset minutes
    fi

    if [ $hours -gt 0 ]; then
        hours="$hours""h "
    else
        unset hours
    fi

    if [ $days -gt 0 ]; then
        days="$days""d "
    else
        unset days
    fi

    if [ $weeks -gt 0 ]; then
        weeks="$weeks""w "
    else
        unset weeks
    fi
    echo "$weeks$days$hours$minutes$seconds"
    #echo "$weeks""w"" $days""d"" $hours""h"" $minutes""m"" $seconds""s"
}

function newLogDay {
	echo "DAY=\"$(day)\"" > $1/.work
	echo "TODAY=\"$(today)\"" >> $1/.work
	chmod 700 $1/.work
	source $1/.work
}

function log {
	if readbool "$__AWESOME_DAEMON"; then
		daemontext="[-]"
	else
		daemontext="[x]"
	fi
	if [ -z "$2" ]; then
		log="$MY_LOG"
	else
		log="$2"
	fi
	if [ ! -d $LOG_LOCATION ]; then
		rm -rf $LOG_LOCATION
		mkdir -p $LOG_LOCATION
		newLogDay $LOG_LOCATION
	elif [ -z "$DAY" ]; then
		source $LOG_LOCATION/.work
	fi
	if [ ! -d "$log" ]; then
		if [ -e "$log" ]; then
			rm -rf "$log"
		fi
		mkdir -p "$log"
	fi
	if [ "$DAY" != "$(day)" ] && [ -e "$log/latest.log" ]; then
		for d in $LOG_LOCATION/*/ ; do
			if [ ! -e "$(realpath $d/latest.log)" ]; then
				continue
			fi
    		mv $(realpath $d/latest.log) $(realpath -m $d/old-$TODAY.log)
			echo -n "" > $(realpath $d/latest.log)
			chown $USER:$USER $(realpath $d/latest.log)
		done
		newLogDay $LOG_LOCATION
	fi
	echo "[$$]$daemontext-$(logTimeFormat) $1" >> "$log/latest.log"
}

function logs {
	echo -e "$1$2$FC_RESET"
	log "$2"
}

function logProcessor {
	declare -A STATE
	#generate regex to match any of the selected releases
	if [ -z "$(grep -o "," <<< $release)" ]; then
		releases_regex="($release)"
	else
		releases_regex="("
		cr="aa"
		c=1
		while [ ! -z "$cr" ]; do
			cr="$(cut -d',' -f$c <<< $release)"
			releases_regex="$releases_regex""$([ ! -z "$cr" ] && echo $cr)""$([ ! -z "$(cut -d',' -f$(($c+1)) <<< $release)" ] && echo "|")"
			c=$(($c+1))
		done
		releases_regex="$releases_regex)"
	fi
	#generate regex to match any of the selected architectures
	if [ -z "$(grep -o "," <<< $arch)" ]; then
		arches_regex="($arch)"
	else
		arches_regex="("
		cr="aa"
		c=1
		while [ ! -z "$cr" ]; do
			cr="$(cut -d',' -f$c <<< $arch)"
			arches_regex="$arches_regex""$([ ! -z "$cr" ] && echo $cr)""$([ ! -z "$(cut -d',' -f$(($c+1)) <<< $arch)" ] && echo "|")"
			c=$(($c+1))
		done
		arches_regex="$arches_regex)"
	fi
	log "--------------------------"
	while read line; do
		echo "$line" >> $MY_LOG/dumpfile-$(today).log
		if [ ! -z "$(grep -o "gzip: stdin: unexpected end of file" <<< $line)" ]; then
			STATE[GZIP_UB_EOF]="true"
			log "$line"
			continue
		fi
		if [ ! -z "$(grep -o "NO_PUBKEY" <<< $line)" ]; then
			STATE[missing-key]="true"
			log "Missing key found"
			continue
		fi
		if [ ! -z "$(grep -oE "Files to download: [0-9]+ MiB" <<< $line)" ]; then
			download="$(grep -oE "[0-9]+ MiB" <<< $line | grep -oE "[0-9]+")"
			STATE[total-download]="$download"
			log "reached download stage; $download MiB"
		fi
		if [ ! -z "$(grep -oE "^Cleanup mirror.$" <<< $line)" ]; then
			log "reached cleanup stage"
		fi
		if [ ! -z "$(grep -oE "^All done.$" <<< $line)" ]; then
			STATE[archive-update-finished]=true
		fi
		if [ ! -z "$(grep -o "Parsing Packages and Sources files ..." <<< $line)" ]; then
			log "reached parsing stage"
		fi
		if [ ! -z "$(grep -oE "pool/.*\.(deb|gz|xz|dsc)" <<< $line)" ]; then
			log "File: $(basename $(grep -oE "pool/.*\.(deb|gz|xz|dsc)" <<< $line))"	
		fi
		if [ ! -z "$(grep -oE "dists/$releases_regex/.*(Release|Packages\.xz|Sources\.xz)" <<< $line)" ]; then
			log "Meta File: $line"
		fi
		if [ ! -z "$(grep -oE "dists/.*\.(deb|gz|xz|dsc)" <<< $line)" ]; then
			if [ ! -z "$(grep -o "diff" <<< $line)" ] && [ -z "$(grep -o "patched with" <<< $line)" ]; then
				log "Diff: $(grep -oE "$releases_regex" <<< $line) ""$(grep -oE "(main|contrib|non-free)" <<< $line) ""$(grep -oE "(binary-$arches_regex|Sources\.diff)" <<< $line) ""File: $(basename $(grep -oE "dists/.*\.(deb|gz|xz|dsc)" <<< $line))"	
			elif [ ! -z "$(grep -o "patched with" <<< $line)" ]; then
				log $line
			fi
		fi
	done
	log "xxxxxxxxxxxxxxxxxxxxx"
	declare -p STATE
}

function riseDebmirrorLock {
	if [ ! -e "$outPath/Archive-Update-in-Progress-$HOSTNAME" ]; then return 0; fi
	rm -f "$outPath/Archive-Update-in-Progress-$HOSTNAME"
	if [ -e "$outPath/Archive-Update-in-Progress-$HOSTNAME" ]; then
		logs "$FC_RED$FC_GREEN" "couldn't erase debmirror's lock"
		return 1
	else
		return 0
	fi
}

function updateKeyring {
	logs "$FC_YELLOW" "trying to update keyring"
	case $keyring_source_type in
		http)
			wget -qO - $keyring_source | gpg --no-default-keyring --keyring $GNUPGHOME/trustedkeys.gpg --import -
		;;
		local)
			gpg --no-default-keyring --keyring $GNUPGHOME/trustedkeys.gpg --import $keyring_source
		;;
	esac
	UPDATED_KEYRING=true
}

function runmirror {
	
	start=$(timestamp)
	logs "$FC_BOLD$FC_GREEN" "Archive update started"

	if [ $cache_days -gt 0 ]; then
		cache_days=" --state-cache-days $cache_days"
	else
		unset cache_days
	fi

	command="debmirror -a $arch -s $section -h $server -d $release -r $inPath --progress --method=$proto $outPath --checksums --i18n$cache_days"
	
	if crudeLock "update.$MirrorName"; then
		if riseDebmirrorLock; then
			while ! readbool "${STATE[archive-update-finished]}"; do
				eval "$(eval "$command" 2>&1 | logProcessor)"
				riseDebmirrorLock
				if [ -z "$total_download" ]; then
					total_download="${STATE[total-download]}"
				fi
				if readbool "${STATE[missing-key]}"; then
					unset STATE[missing-key]
					if ! readbool "$UPDATED_KEYRING"; then
						updateKeyring
					else
						logs "$FC_RED$FC_BOLD" "couldn't update the keyring"
						exit 0
					fi
				fi
				if readbool "${STATE[GZIP_UB_EOF]}"; then
					if ! readbool "$_WORKAROUND_GZIP_EOF"; then
						log "GZIP unexpected EOF, corrupted gz files can cause this error"
						log "implementing workaround: nuke $outPath/.temp"
						rm -rf $outPath/.temp
						_WORKAROUND_GZIP_EOF=true
						unset STATE[GZIP_UB_EOF]
					else
						log "GZIP unexpected EOF, corrupted gz files can cause this error"
						log "workaround: nuke $outPath/.temp din't work"
						exit 0
					fi
				fi
			done
		else
			logs "$FC_YELLOW$FC_BOLD" "could not rise debmirrors lockfile"
			exit 0
		fi
	else
		echo -e "$FC_YELLOW$FC_BOLD""could not acquire update lock"
		exit 0
	fi
	
	secondstook=$(($(timestamp)-$start))
	spent=$(unixTimeDiffToReadable $secondstook)
	if [ -z "$total_download" ]; then
		total_download=", didn't require download"
	else
		total_download=", total download was: $total_download MiB"
	fi
	logs "$FC_GREEN$FC_BOLD" "Archive update finished after $spent$total_download"
	riseCrudeLock "update.$MirrorName"
	LAST_SUCCESSFUL_UPDATE="$(timestamp)"
	declare -p LAST_SUCCESSFUL_UPDATE > $LOG_LOCATION/$MirrorName/last_update.bvar
	chmod +x $LOG_LOCATION/$MirrorName/last_update.bvar
}

function srunmirror {
	source $LOG_LOCATION/$MirrorName/last_update.bvar 2> /dev/null
	[ -z "$LAST_SUCCESSFUL_UPDATE" ] && LAST_SUCCESSFUL_UPDATE=$(($(timestamp)-$(($how_old*3600))))
	if [ $(($(timestamp)-$LAST_SUCCESSFUL_UPDATE)) -ge $(($how_old*3600)) ] && readbool "$ingnore_time"; then
		log "asked if allowed to update but repo too old, updating anyways"
		runmirror
	else
		start_h="$(grep -oE "[0-9]+/" <<< $start_hour | grep -oE "[0-9]+")"
		start_m="$(grep -oE "/[0-9]+" <<< $start_hour | grep -oE "[0-9]+")"
		end_h="$(grep -oE "[0-9]+/" <<< $end_hour | grep -oE "[0-9]+")"
		end_m="$(grep -oE "/[0-9]+" <<< $end_hour | grep -oE "[0-9]+")"
		h=$(date "+%H")
		m=$(date "+%M")
		if [ $start_h -eq $h ]; then
			if [ $m -ge $start_m ]; then
				runmirror
			fi
		else
			if [ $h -gt $start_h ]; then
				if [ $end_h -eq $h ]; then
					if [ $m -le $end_m ]; then
						runmirror
					fi
				else
					if [ $h -lt $end_h ]; then
						runmirror
					fi
				fi
			fi
		fi
	fi
}

if [ $# -eq 0 ] || [ $# -gt 1 ]; then
	echo "options:"
	echo "	run			run the mirror"
	echo "	srun 		run if it's currently the set hours"
	echo "	hook-log 	see the logfile generated by this script"
	echo "	hook-dump 	see debmirror's output"
	echo "	getkeyring 	try to import the keyring again"
	echo "	userfiles 	see the location of the logfiles and keyrings"
	echo "	version 	:v"
fi

case $1 in
	version)
		displayCopyright
	;;

	run)
		runmirror
	;;

	srun)
		__AWESOME_DAEMON=true
		srunmirror
	;;

	getkeyring)
		updateKeyring
	;;

	userfiles)
		echo $USER_FILES_LOCATION
	;;

	hook-log)
		tail -f $LOG_LOCATION/$MirrorName/latest.log
	;;

	hook-dump)
		tail -f $LOG_LOCATION/$MirrorName/dumpfile-$(today).log
	;;

esac


export PS1="$PREVIOUS_PS1"